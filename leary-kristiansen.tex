% Document setup
\documentclass[article, a4paper, 11pt, oneside]{memoir}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[UKenglish]{babel}

% Document info
\newcommand\doctitle{Leary \& Kristiansen, \emph{A Friendly Introduction to Mathematical Logic}}
\newcommand\docauthor{Danny Nyg√•rd Hansen}

% Formatting and layout
\usepackage[autostyle]{csquotes}
\usepackage[final]{microtype}
\usepackage{xcolor}
\frenchspacing
\usepackage{latex-sty/articlepagestyle}
\usepackage{latex-sty/articlesectionstyle}
% \usepackage{latex-sty/amalgsymbol}

% Fonts
\usepackage[largesmallcaps]{kpfonts}
\DeclareSymbolFontAlphabet{\mathrm}{operators} % https://tex.stackexchange.com/questions/40874/kpfonts-siunitx-and-math-alphabets
\linespread{1.06}
\let\mathfrak\undefined
\usepackage{eufrak}
\usepackage{inconsolata}
% \usepackage{amssymb}

% Hyperlinks
\usepackage{hyperref}
\definecolor{linkcolor}{HTML}{4f4fa3}
\hypersetup{%
	pdftitle=\doctitle,
	pdfauthor=\docauthor,
	colorlinks,
	linkcolor=linkcolor,
	citecolor=linkcolor,
	urlcolor=linkcolor,
	bookmarksnumbered=true
}

% Equation numbering
\numberwithin{equation}{chapter}

% Footnotes
\footmarkstyle{\textsuperscript{#1}\hspace{0.25em}}

% Mathematics
\usepackage{latex-sty/basicmathcommands}
\usepackage{latex-sty/framedtheorems}
\usepackage{latex-sty/topologycommands}
\usepackage{tikz-cd}
\tikzcdset{arrow style=math font} % https://tex.stackexchange.com/questions/300352/equalities-look-broken-with-tikz-cd-and-math-font
\usetikzlibrary{babel}

% Lists
\usepackage{enumitem}
\setenumerate[0]{label=\normalfont(\alph*)}
\setlist{  
  listparindent=\parindent,
  parsep=0pt,
}

% Bibliography
\usepackage[backend=biber, style=authoryear, maxcitenames=2, useprefix]{biblatex}
\addbibresource{references.bib}

% Title
\title{\doctitle}
\author{\docauthor}

\newcommand{\setF}{\mathbb{F}}
\newcommand{\ev}{\mathrm{ev}}
\newcommand{\calT}{\mathcal{T}}
\newcommand{\calU}{\mathcal{U}}
\newcommand{\calB}{\mathcal{B}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calG}{\mathcal{G}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calP}{\mathcal{P}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\calO}{\mathcal{O}}
\newcommand{\calL}{\mathcal{L}}
\newcommand{\strucS}{\mathfrak{S}}
\DeclarePairedDelimiter{\gen}{\langle}{\rangle} % Generating set
\newcommand{\frakL}{\mathfrak{L}}
\newcommand{\frakN}{\mathfrak{N}}
\newcommand{\frakA}{\mathfrak{A}}
\newcommand{\frakB}{\mathfrak{B}}
\newcommand{\ab}{\mathit{ab}}

\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\coker}{coker}
\DeclareMathOperator{\stab}{Stab}

% Categories
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\scat}[1]{\mathbf{#1}} % category supposed to be small
\newcommand{\ncat}[1]{\mathbf{#1}} % named categories like Set, Top

\newcommand{\catSet}{\ncat{Set}} % Category of sets
\newcommand{\catGrp}{\ncat{Grp}} % Category of groups
\newcommand{\catAb}{\ncat{Ab}} % Category of abelian groups
\newcommand{\catRing}{\ncat{Ring}} % Category of rings
\newcommand{\catFld}{\ncat{Fld}} % Category of fields

\newcommand{\catMod}[1]{{#1\text{-}\scat{Mod}}}
\newcommand{\catRMod}{\catMod{R}}

\newcommand{\End}{\mathrm{End}}
\newcommand{\Hom}{\mathrm{Hom}}

\DeclareMathOperator{\chr}{char}

% https://tex.stackexchange.com/a/124311/63353
\makeatletter
\g@addto@macro\bfseries{\boldmath}
\makeatother

\newcommand{\keyword}[1]{{\bfseries #1}}


%% Framed exercise environment

\mdfdefinestyle{swannexercise}{%
    skipabove=0.5em plus 0.4em minus 0.2em,
	skipbelow=0.5em plus 0.4em minus 0.2em,
	leftmargin=-5pt,
	rightmargin=-5pt,
	innerleftmargin=5pt,
	innerrightmargin=5pt,
	innertopmargin=5pt,
	innerbottommargin=4pt,
	linewidth=0pt,
	splittopskip=1.2em minus 0.2em,
	splitbottomskip=0.5em plus 0.2em minus 0.1em,
	backgroundcolor=backgroundcolor,
	frametitlebackgroundcolor=titlecolor,
	frametitlefont={\scshape},
    theoremseparator={},
    % theoremspace={},
	frametitleaboveskip=3pt,
	frametitlebelowskip=2pt
}

\mdtheorem[style=swannexercise]{exerciseframed}{Exercise}

\let\oldexerciseframed\exerciseframed
\renewcommand{\exerciseframed}{%
  \crefalias{theorem}{exerciseframed}%
  \oldexerciseframed}

\usepackage{listofitems}

\settocdepth{subsection}
\renewenvironment{exerciseframed}[1][]{%
    \setsepchar{.}%
    \readlist*\mylist{#1}%
    \def\smalllabel{\mylist[2].\mylist[3]}%
    \refstepcounter{exerciseframed}%
    % \addcontentsline{toc}{subsection}{Exercise \smalllabel}%
    \begin{exerciseframed*}[#1]%
    \label{ex:#1}%
}{%
    \end{exerciseframed*}%
}

% https://tex.stackexchange.com/a/23491/63353
\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

\newcommand{\exref}[1]{%
    % \setsepchar{.}%
    % \readlist*\mylist{#1}%
    % \ifnum \arabic{chapter}=\mylist[1]
    %     \def\mylabel{\mylist[2].\mylist[3]}%
    % \else
    %     \def\mylabel{\RNum{\mylist[1]}.\mylist[2].\mylist[3]}%
    % \fi
    \hyperref[ex:#1]{Exercise~#1}%
}

\theoremstyle{nonumberplain}
\theoremsymbol{\ensuremath{\square}}
\newtheorem{solution}{Solution}

\let\oldsolution\solution
\renewcommand{\solution}{%
  \crefalias{theorem}{solution}%
  \oldsolution}

\newcommand{\solutionlabelfont}[1]{{\normalfont\color{linkcolor}#1}}
\newlist{solutionsec}{enumerate}{1}
\setlist[solutionsec]{leftmargin=0pt, parsep=0pt, listparindent=\parindent, font=\solutionlabelfont, label=(\alph*), labelsep=0pt, labelwidth=20pt, itemindent=20pt, align=left, itemsep=10pt}


% \renewcommand{\thechapter}{\Roman{chapter}}
% \renewcommand{\thesection}{\arabic{section}}

\DeclarePairedDelimiter{\ord}{\lvert}{\rvert}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\Inn}{Inn}

\usepackage{caption} % Links to figures jump correctly
\Crefname{figure}{Figure}{Figures}


\newenvironment{displaytheorem}{%
	\begin{displayquote}\itshape%
}{%
	\end{displayquote}%
}


\newcommand{\upset}{\operatorname{\uparrow}}
\newcommand{\downset}{\operatorname{\downarrow}}
\newcommand{\matgroup}[3]{\mathrm{#1}_{#2}(#3)}
\newcommand{\GL}[2]{\matgroup{GL}{#1}{#2}}
\newcommand{\SL}[2]{\matgroup{SL}{#1}{#2}}
\newcommand{\catGSet}[1][G]{{#1\text{-}\catSet}}
\newcommand{\frakI}{\mathfrak{I}}
\newcommand{\field}{\mathbb{F}}
\let\bigcoprod\coprod
\renewcommand{\coprod}{\sqcup}


% For logic
\renewcommand{\mylistlabelfont}[1]{{\normalfont\color{linkcolor}\textit{#1}:}}
\newlist{notelist}{description}{1}
\setlist[notelist]{leftmargin=0pt, parsep=0pt, listparindent=\parindent, font=\mylistlabelfont}

% TODO positive integers
\newcommand{\posints}{\ints_+}


\begin{document}

\maketitle

\chapter{Structures and Languages}

\newcommand{\limplies}{\vDash}
\newcommand{\valid}{\vDash}
\newcommand{\lcond}{\rightarrow}
\let\oldmodels\models
\renewcommand{\models}{\vDash}
\newcommand{\sats}[1]{\vDash_{#1}}
\newcommand{\notsats}[1]{\not\vDash_{#1}}
\newcommand{\vars}{\mathit{Vars}}

\begin{notelist}
    \item[Languages]
    A \keyword{first-order language} $\calL$ is actually an (infinite) alphabet consisting of the usual symbols. Notice that we have a \emph{countable} number of variables. These variables are common to all first-order languages, so we use the symbol $\vars$, which does not depend on which language we are considering, to denote the set of variables.
    
    On the other hand we can have an arbitrary number of constant, function and relation symbols. I am not sure if the number of these symbols makes any difference to the theory. Instead of having a separate category for constants we may consider a constant as a function with arity $0$. The arity of function symbols may, as in universal algebra, be formalised as a partial function $\rho \colon \calL \nrightarrow \naturals$, whose domain is the set of function and relation symbols.

    \item[Terms]
    Strings can be terms of a particular first-order language $\calL$. We think of terms as picking out an element of the universe under consideration. These are obtained either as variables or as the images of functions in $\calL$ (or as constants if these are considered a class of their own).
    
    \item[Formulas]
    As with terms, strings can be formulas of a particular first-order language $\calL$. Formulas are supposed to represent propositions about the objects in the universe. We may first construct formulas from $\calL$-terms by applying relations (e.g. equality) to a list of terms. Afterwards we may apply either quantifiers or the usual connectives from propositional logic to the resulting formulas. Notice that the particular language $\calL$ only determines which terms are allowed and does not affect how these terms can be used to construct formulas.
    
    A formula is said to be \keyword{atomic} if it is on the form $= t_1 t_2$ or $R t_1 \cdots t_n$ for an $n$-ary relation symbol $R$ and terms $t_1, \ldots, t_n$.
    
    We say that a string $\psi$ is a \keyword{subformula} of a formula $\phi$ if $\psi$ itself is a formula, and if it is a substring of $\phi$. By unique readability for formulas (Exercise~1.4.8) each formula $\phi$ that is not atomic can be broken up into smaller formulas in a unique way. These give rise to a (unique) construction tree for $\phi$, and the subformulas are precisely the formulas that appear on this tree.

    L\&K call the symbol $\forall$ itself a quantifier, but by \keyword{quantifier} we will mean $\forall v$ for a variable $v$. The \keyword{scope} of a quantifier $\forall v$ occurring in a formula $(\forall v)(\alpha)$ is the subformula $\alpha$.

    \item[Free variables]
    We define recursively what it means for a variable $v$ to be \keyword{free} in a formula $\phi$. Alternatively we may simply say that $v$ is free in $\phi$ if it is not in the scope of any quantifier $\forall v$ occurring in $\phi$.
    
    This also makes it easy to define what it means for an \keyword{occurrence} of a variable $v$ in $\phi$ to be free: Namely that this occurrence does not lie in the scope of any quantifier $\forall v$.

    \item[Sentences]
    A \keyword{sentence} in $\calL$ is a formula of $\calL$ with no free variables.
    
    \item[Structures]
    An \keyword{$\calL$-structure} $\frakA$ consists of a nonempty set $A$, the \keyword{universe} of $\frakA$, along with functions $f^\frakA \colon A^{\rho(f)} \to A$ and relations $R^\frakA \in A^{\rho(R)}$ for each function symbol $f$ and relation symbol $R$ in $\calL$. The particular language $\calL$ does not place any constraints on the universe $A$.
    
    Compare this to universal algebra: Here we usually specify a collection $\calF$ of operation symbols and a type $\rho \colon \calF \to \naturals$ specifying the arity of each symbol. A structure $\frakA$ of type $\rho$ is then a nonempty set $A$ along with $\rho(f)$-ary operations $f^\frakA$ on $A$ for each $f \in \calF$. In first-order logic we also allow relations, but otherwise the definition of a structure is basically the same.

    \item[Variable assignment functions]
    A \keyword{(variable) assignment function} into an $\calL$-structure $\frakA$ is a function $\vars \to A$. This is the first step towards connecting the syntax and semantics of $\calL$. Notice that regardless of the particular structure or language, it is always the variables in $\vars$ that we need to assign values to. The codomain $A$ however is determined by the structure $\frakA$ in question, which itself depends on the language $\calL$ (though $A$ does not as such depend on $\calL$).

    Given $s \colon \vars \to A$, a variable $x$ and a particular value $a \in A$, we define an \keyword{$x$-modification} of $s$ denoted $s[x \mid a]$ with $s[x \mid a](x) = a$.

    \item[Term assignment function]
    Given $s \colon \vars \to A$ we define the \keyword{term assignment function} $\overline{s}$ generated by $s$. This is defined by recursion on terms, and it is clearly the unique extension $s'$ of $s$ to all terms satisfying that
    %
    \begin{equation*}
        s'(f t_1 \cdots t_n)
            = f^\frakA (s'(t_1), \ldots, s'(t_n))
    \end{equation*}
    %
    for all function symbols $f$ and all terms $t_1, \ldots, t_n$. Indeed, Lemma~1.7.6 shows that only the variables occurring in a particular term $t$ determines the value of $\overline{s}$ in $t$.

    \item[Satisfaction]
    We define what it means for an $\calL$-structure $\frakA$ to \keyword{satisfy} an $\calL$-formula $\phi$ with assignment $s \colon \vars \to A$ recursively. In the affirmative case we write $\frakA \sats{s} \phi$.
    
    The base cases are the atomic formulas. This completes the connection between the syntax and semantics of $\calL$: We have now effectively associated a truth value to each $\calL$-formula, provided that we are given an interpretation of all the symbols in such a formula, namely function symbols (i.e. $\frakA$) and variables (i.e. $s$).

    Notice that the definition of satisfaction is \emph{informal}, even if it is precise. Clearly we cannot hope to define the semantics of $\calL$ in terms of $\calL$ itself, so we must resort to a definition in natural language using terms like \enquote{not}, \enquote{or} and \enquote{for all}.

    Proposition~1.7.7 shows that satisfaction of a formula $\phi$ only depends on the free variables occurring in $\phi$.

    \item[Models and validity]
    An $\calL$-structure $\frakA$ is a \keyword{model} of an $\calL$-formula $\phi$, written $\frakA \models \phi$, if $\frakA \sats{s} \phi$ for all assignment functions $s$. In in turn $\frakA \models \phi$ for all $\calL$-structures $\frakA$, then we say that $\phi$ is \keyword{valid} and write $\valid \phi$.

    If $\sigma$ is a sentence in $\calL$, then $\frakA \models \sigma$ if and only if $\frakA \sats{s} \sigma$ for \emph{any} $s$, in which case we say that $\sigma$ is \keyword{true in $\frakA$}.

    \item[Substitutions]
    We define recursively how to substitute a term in place of a variable, first in terms and then in formulas. L\&K use the notation $u^x_t$ for the term $u$ with every occurrence of $x$ replaced with the term $t$, but the notation $u[t/x]$ is also common. We similarly write $\phi^x_t$ for a formula $\phi$. % TODO: Decide which to use myself

    If $\phi$ is a formula, $t$ a term and $x$ a variable, then we define when $t$ is \keyword{substitutable} for $x$ in $\phi$. We do this by recursion, and the case when $\phi$ is on the form $(\forall y)(\alpha)$ is the interesting one. In this case $t$ is substitutable for $x$ if either of the following holds:
    %
    \begin{enumerate}
        \item $x$ is not free in $\phi$, which includes the case when $y = x$. In this case every occurrence of $x$ (as a variable and not in a quantifier) in $\phi$ lies in the scope of a quantifier $\forall x$. But when performing the substitution $\phi^x_t$ the relevant subformula $(\forall x)(\beta)$ is left untouched. Hence there is no danger of making a substitution in a problemating place, since we aren't making any substitutions!

        \item $y$ does not occur in $t$, and $t$ is substitutable for $x$ in $\alpha$. A problem could happen if the former is not satisfied, since any free occurrence of $y$ would be bound by the quantifier, which is not desirable. The latter condition is of course necessary.
    \end{enumerate}

    \item[Logical implication]
    If $\Gamma$ and $\Delta$ are sets of $\calL$-formulas, then we say that $\Gamma$ \keyword{logically implies} $\Delta$, denoted $\Gamma \limplies \Delta$, if $\frakA \models \Gamma$ implies $\frakA \models \Delta$ for all $\calL$-structures $\frakA$.

    Note the asymmetry in the roles played by structures and variable assignment functions in the definition of logical implication: It is \emph{not} the case that $\Gamma \limplies \Delta$ means that
    %
    \begin{equation*}
        \frakA \sats{s} \Gamma
        \quad \text{implies} \quad
        \frakA \sats{s} \Delta
    \end{equation*}
    %
    for all $\calL$-structures $\frakA$ and variable assignment functions $s$ into $\frakA$. This would require us to assign the same values to variables in $\Gamma$ and in $\Delta$, but this is not needed. However, it also does not mean that
    %
    \begin{equation*}
        \frakA \sats{s} \Gamma
        \quad \text{implies} \quad
        \frakA \sats{t} \Delta
    \end{equation*}
    %
    for all $\calL$-structures $\frakA$ and variable assignment functions $s,t$ into $\frakA$. This says that we require $\frakA \sats{t} \Delta$ to hold for all $t$ as soon as $\frakA \sats{s} \Gamma$ holds for \emph{some} $s$. But we only require $\frakA \sats{t} \Delta$ when we assume $\frakA \sats{s} \Gamma$ for \emph{all} $s$. That is, when proving $\frakA \sats{t} \Delta$ we may construct whatever $s$ we wish.

    If $\emptyset \limplies \phi$, then we say that $\phi$ is \keyword{valid} and write $\valid \phi$. This agrees with the definition of validity above.
\end{notelist}



\begin{exerciseframed}[1.9.3]
    Suppose that $\phi$ is an $\calL$-formula and $x$ is a variable. Prove that $\phi$ is valid if and only if $(\forall x)(\phi)$ is valid. Thus, if $\phi$ has free variables $x$, $y$, and $z$, $\phi$ will be valid if and only if $\forall x \forall y \forall z \phi$ is valid. The sentence $\forall x \forall y \forall z \phi$ is called the \keyword{universal closure} of $\phi$.
\end{exerciseframed}

\begin{solution}
    Notice that $\valid (\forall x)(\phi)$ if and only if $\frakA \sats{s} (\forall x)(\phi)$ for all $\calL$-structures $\frakA$ and variable assignment functions $s$ into $\frakA$. This is the case if and only if $\frakA \sats{s[x \mid a]} \phi$ for all $\frakA$, $s$ and elements $a$ in the universe $A$. If $\phi$ is valid then this follows.
    
    Conversely, notice that $s = s[x \mid s(x)]$, so every variable assignment function into $\frakA$ is on the form $s[x \mid a]$ for some $s$ and $a$ in $A$. Hence if $(\forall x)(\phi)$ is valid, then the above implies that $\frakA \sats{s} \phi$ for all $\frakA$ and $s$. Thus $\frakA \models \phi$ for all $\frakA$, so $\valid \phi$.
\end{solution}


\begin{exerciseframed}[1.9.4]
    \begin{enumerate}
        \item Assume that $\limplies (\phi \lcond \psi)$. Show that $\phi \limplies \psi$.
        \item Suppose that $\phi$ is $x < y$ and $\psi$ is $z < w$. Show that $\phi \limplies \psi$ but $\not\valid (\phi \lcond \psi)$.
    \end{enumerate}
\end{exerciseframed}

\begin{solution}
\begin{solutionsec} % TODO why different vDashes with not and subscript??
    \item Let $\frakA$ be a structure such that $\frakA \models \phi$, and let $s$ be any variable assignment function into $\frakA$. In particular we thus have $\frakA \sats{s} \phi$. Furthermore, $\frakA \sats{s} (\phi \to \psi)$, which is the case if and only if either $\frakA \notsats{s} \phi$ or $\frakA \sats{s} \psi$. The former is impossible, so the latter holds. Since $s$ was arbitrary we have $\frakA \models \psi$, so $\phi \limplies \psi$ as desired.
    
    \item We first show that $\phi \limplies \psi$, so let $\frakA$ be a structure such that $\frakA \models \phi$. We must then show that $\frakA \models \psi$. If ${<^\frakA} = A \prod A$ then this is obvious. Assume thus that there exist $a,b \in A$ such that $(a,b) \not\in {<^\frakA}$, i.e. such that $a <^\frakA b$ is false. Let $s$ be a variable assignment function into $\frakA$ with $s(x) = a$ and $s(y) = b$. Then $\frakA \notsats{s} \phi$, so nothing has to be proved. This shows that $\phi \limplies \psi$.
    
    We next show that $\frakN \not\models (\phi \lcond \psi)$. Let $r$ be a variable assignment function into $\frakN$ with $r(x) = 0$, $r(y) = 1$, $r(z) = 1$, and $r(w) = 0$. Then $\frakN \sats{r} \phi$ but $\frakN \notsats{r} \psi$, so $\frakN \notsats{r} (\phi \lcond \psi)$ as desired.
\end{solutionsec}
\end{solution}


\chapter{Deductions}

\newcommand{\proves}{\vdash}
\newcommand{\thm}[1]{\mathrm{Thm}_{#1}}
\newcommand{\colonequiv}{\mathbin{\vcentcolon\equiv}}

\begin{notelist}
    \item[Deductions]
    We fix a language $\calL$, a set $\Lambda$ of \emph{logical axioms}, and a set of ordered pairs $(\Gamma,\phi)$ called \emph{rules of inference}. We further have a set $\Sigma$ of \emph{nonlogical axioms}, whose content depends on the application. A \emph{deduction from $\Sigma$} is then a finite sequence of $\calL$-formulas such that each formula is either an axiom or follows from the previous formulas by the rules of inference. If there exists a deduction from $\Sigma$ whose last element is $\phi$, then this deduction is called a \emph{deduction from $\Sigma$ of $\phi$}, and we write $\Sigma \proves \phi$.

    We denote by $\thm{\Sigma}$ the set of formulas $\phi$ such that $\Sigma \proves \phi$. This is clearly the smallest set of formulas containing the axioms that is closed under application of the rules of inference.

    \item[Logical axioms]
    The logical axioms include:
    %
    \begin{enumerate}
        \item[$(E_1)$] Reflexivity of variables, i.e. $x = x$ for every variable $x$.
        \item[$(E_2)$] Substitution in function symbols: If two variables are the same, we can substitute them as arguments to any function symbol.
        \item[$(E_3)$] Substitution in relation symbols: Same as above, but for relation symbols.
    \end{enumerate}
    %
    For instance, for each $n$-ary function symbol $f$ in $\calL$ and each collection $x_1, \ldots, x_n, y_1, \ldots, x_n$ of variables we get an axiom of the second kind above. Hence even if there is only one function symbol in $\calL$, as long as this as positive arity there are infinitely many axioms of this kind: If $f$ is unary, then we have an axiom
    %
    \begin{equation*}
        v_i = v_j \lcond f(v_i) = f(v_j)
    \end{equation*}
    %
    for all $i,j \in \posints$. Hence we already have a potentially massive collection of axioms.

    We also have axioms for quantifiers. For every variable $x$, term $t$ and formula $\phi$ such that $t$ is substitutable for $x$ in $\phi$ we have the following:
    %
    \begin{enumerate}
        \item[$(Q_1)$] Universal instantiation: $(\forall x \phi) \lcond \phi^x_t$.
        \item[$(Q_2)$] Existential generalisation: $\phi^x_t \lcond (\exists x \phi)$.
    \end{enumerate}

    \item[Propositional consequence]
    Consider the restricted language $\calP$ only containing a set of propositional variables and the logical connectives. Formulas of $\calP$ are given recursively in the usual way, and the semantics of $\calP$ is that of standard propositional logic. In particular, a formula of $\calP$ is a \emph{tautology} if every assignment of truth values to the propositional variables makes it true.

    Given an $\calL$-formula $\phi$, we convert it to a $\calP$-formula $\phi_P$ as follows:
    %
    \begin{enumerate}
        \item Systematically replace with propositional variables every occurrence of subformulas on the form $(\forall x)(\alpha)$ that are not in the scope of another quantifier.
        \item Systematically replace in a systematic way with propositional variables every remaining atomic subformula.
    \end{enumerate}
    %
    By \enquote{systematically} we mean that multiple occurrences of the same subformula is replaced with the same propositional variable. 

    If $\Gamma_P$ is a set of $\calP$-formulas and $\phi_P$ is a $\calP$-formula, then $\phi_P$ is a \emph{propositional consequence} of $\Gamma_P$ if $\phi_P$ is true under every truth assignment making every formula in $\Gamma_P$ true.

    If $\Gamma$ is a \emph{finite} set of $\calL$-formulas and $\phi$ is an $\calL$-formula, then $\phi$ is a \emph{propositional consequence} of $\Gamma$ if $\phi_P$ is a propositional consequence of $\Gamma_P$. I'm not sure exactly how significant the finiteness condition is. Perhaps it has to do with us having to go through every formula in $\Gamma$ and convert each to a propositional formula? Perhaps the corresponding rules of inference will not be decidable.

    \item[Rules of inference]
    We first have the following:
    %
    \begin{enumerate}
        \item[(PC)] If an $\calL$-formula $\phi$ is a propositional consequence of a finite set $\Gamma$ of $\calL$-formulas, then $(\Gamma,\phi)$ is a rule of inference.
    \end{enumerate}
    
    We also have the rules
    %
    \begin{equation*}
        \bigl( \{ \psi \lcond \phi \}, \psi \lcond (\forall x)(\phi) \bigr)
        \quad \text{and} \quad
        \bigl( \{ \phi \lcond \psi \}, (\exists x)(\phi) \lcond \psi \bigr)
    \end{equation*}
    %
    of type (QR), where $x$ is not free in $\psi$. This assumption is supposed to formalise that we make no assumptions about $x$. Intuitively, if $x$ occurs in $\psi$ then we may simply make the substitution $\psi^x_y$, where $y \neq x$ is a variable that does not occur in $\psi$. If we can then somehow prove a formula $\phi$ in which $x$ is free, then this $x$ cannot have come from $\psi$. Hence $\phi$ must hold whatever $x$ is.
    
    The second rule says that if $x$ somehow \enquote{disappears} when proving $\psi$, then it didn't matter what $x$ was. Hence it's enough that there exists some $x$.

    \item[Soundness]
    If $\Sigma \proves \phi$, then $\Sigma \limplies \phi$. The proof goes through the following steps:
    %
    \begin{enumerate}
        \item \emph{The logical axioms are valid}: The equality axioms are easy, and the quantifier axioms are clear enough but require a technical lemma (Theorem~2.6.2).
        
        \item \emph{If $(\Gamma,\theta)$ is a rule of inference, then $\Gamma \limplies \theta$}: For rules of type (PC) this follows by applying \exref{2.4.3}, then \exref{2.4.6}, and finally \exref{1.9.4}. For the rules of type (QR), this is shown by explicitly considering structures, applying Proposition~1.7.7 to make use of free variables (here we use the assumption that $x$ is not free in $\psi$).
        
        \item \emph{Proof of soundness}: We show that $\thm{\Sigma} \subseteq C \defn \set{\phi}{\Sigma \limplies \phi}$ by induction, showing that $C$ contains both $\Sigma$ and $\Lambda$, and that it is closed under application of any rule of inference $(\Gamma,\theta)$. The former is obvious.
        
        For the latter, assume that $\Gamma \subseteq C$, so that $\Sigma \limplies \Gamma$. For any structure $\frakA$ with $\frakA \models \Sigma$ we thus have $\frakA \models \Gamma$. Since $\Gamma \limplies \theta$ it thus follows that $\frakA \models \theta$.
    \end{enumerate}
\end{notelist}


\begin{exerciseframed}[2.4.3]
    Prove Lemma~2.4.2: If $\Gamma_P = \{ (\gamma_1)_P, (\gamma_2)_P, \ldots, (\gamma_n)_P \}$ is a nonempty finite set of propositional formulas and $\phi_P$ is a propositional formula, then $\phi_P$ is a propositional consequence of $\Gamma_P$ if and only if
    %
    \begin{equation*}
        \bigl[ (\gamma_1)_P \land (\gamma_2)_P \land \ldots \land (\gamma_n)_P \bigr]
            \lcond \phi_P
    \end{equation*}
    %
    is a tautology.
\end{exerciseframed}

\begin{solution}
    Obvious, since the above formula is true if and only if either all $(\gamma_i)_P$ and $\phi_P$ are true, or if at least one $(\gamma_i)_P$ is false.
\end{solution}


\begin{exerciseframed}[2.4.6]
    Prove that if $\theta$ is not valid, then $\theta_P$ is not a tautology. Deduce that if $\theta_P$ is a tautology, then $\theta$ is valid.
\end{exerciseframed}

\begin{solution}
    We prove this by induction on the (propositional) complexity of $\theta$ (i.e. the number of connectives in $\theta$). We in fact prove the following stronger claim:
    %
    \begin{displaytheorem}
        If $\theta$ is not valid, then $\theta_P$ is not a tautology. And if $\frakA \sats{s} \theta$ for some structure $\frakA$ and assignment function $s$, then $\theta_P$ is not a contradiction.
    \end{displaytheorem}
    %
    If $\theta$ is atomic or on the form $(\forall x)(\alpha)$ then this is obvious by the definition of $\theta_P$. Otherwise assume that the above holds for all formulas with smaller complexity than $\theta$. Notice that $\theta$ is not valid if and only if $\frakA \notsats{s} \theta$ for some $\frakA$ and $s$.

    \begin{proofsec}
        \item[$\theta \colonequiv (\neg \alpha)$]
        First assume that $\theta$ is not valid. Notice that $\frakA \notsats{s} \theta$ implies that $\frakA \sats{s} \alpha$, so by induction $\alpha_P$ is not a contradiction. Hence $\theta_P = (\neg \alpha_P)$ is not a tautology.

        On the other hand, if $\frakA \sats{s} \theta$ then $\frakA \notsats{s} \alpha$. Hence $\alpha$ is not valid, so by induction $\alpha_P$ is not a tautology. Thus $\theta_P$ is not a contradiction.

        \item[$\theta \colonequiv (\alpha \lor \beta)$]
        Assume that $\theta$ is not valid, so that $\frakA \notsats{s} \theta$. Then both $\frakA \notsats{s} \alpha$ and $\frakA \notsats{s} \beta$, i.e. neither $\alpha$ nor $\beta$ is valid. It follows by induction that $\alpha_P$ and $\beta_P$ are not tautologies, so neither is $\theta_P \colonequiv (\alpha_P \lor \beta_P)$.

        Next, if $\frakA \sats{s} \theta$ then either $\frakA \sats{s} \alpha$ or $\frakA \sats{s} \beta$. Without loss of generality assume the former. By induction, $\alpha_P$ is then not a contradiction, so neither is $\theta_P$.
    \end{proofsec}
\end{solution}

\newcommand{\false}{\bot}

\begin{exerciseframed}[2.7.4]
    Suppose that $\eta$ is a sentence. Prove that $\Sigma \proves \eta$ if and only if $\Sigma \union (\neg \eta) \proves \false$. Notice that this exercise tells us that our deductive system allows us to do proofs by contradiction.
\end{exerciseframed}
%
Here $\false$ denotes the contradiction $[(\forall x)(x = x)] \land \neg [(\forall x)(x = x)]$.

\begin{solution}
    First assume that $\Sigma \proves \eta$. Notice then that $\Sigma \union (\neg \eta) \proves \eta$, and we also clearly have $\Sigma \union (\neg \eta) \proves (\neg \eta)$. Hence $\Sigma \union (\neg \eta) \proves \{ \eta, (\neg \eta) \}$. But notice that $\{ \eta, (\neg \eta) \} \proves \false$ by (PC) since no truth assignment makes $\{ \eta_P, (\neg \eta_P) \}$ true. This implies that $\Sigma \union (\neg \eta) \proves \false$ as desired.

    Conversely assume that $\Sigma \union (\neg \eta) \proves \false$. But $\{ \false \} \proves \eta$ since any formula is a propositional consequence of $\{ \false \}$. Hence $\Sigma \proves \eta$.
\end{solution}


\chapter{Completeness and Compactness}

\section*{Completeness}

\begin{notelist}
    \item[Reducing to a weaker statement]
    To prove that $\Sigma \limplies \phi$ implies $\Sigma \proves \phi$, we first show that it suffices to prove a seemingly weaker statement:
    %
    \begin{enumerate}
        \item In $\Sigma \proves \phi$ we may assume that $\phi$ is a sentence, since by Lemma~2.7.2, $\Sigma \proves \phi$ if and only if $\Sigma \proves \phi'$, where $\phi'$ is the universal closure of $\phi$. 
        
        The same is true for $\Sigma \limplies \phi$: Here we must show that this implies $\Sigma \limplies \phi'$. It suffices to show that $\Sigma \limplies (\forall x)(\phi)$, i.e. where we add a single quantifier. Let $\frakA$ be a structure such that $\frakA \models \Sigma$. We must then show that $\frakA \sats{s} (\forall x)(\phi)$ for all assignment functions $s$, i.e. that $\frakA \sats{s[x|a]} \phi$ for all $a \in A$. But this is clear since $\frakA \models \phi$.

        \item By Lemma~2.7.3 we may in $\Sigma \proves \phi$ also assume that every element of $\Sigma$ is a sentence: Let $\Sigma'$ be the set of universal closures of elements in $\Sigma$. Then we claim that if $\Sigma' \proves \phi$, then $\Sigma \proves \phi$. For any derivation $D$ from $\Sigma'$, say of the formula $\phi$, let $\Sigma'_D$ be the subset of $\Sigma'$ of all elements from $\Sigma'$ appearing in $D$. Then $D$ is also a derivation from $\Sigma'_D$ to $\phi$, so $\Sigma'_D \proves \phi$. But $\Sigma'_D$ is finite since $D$ is, so the lemma implies that also $\Sigma_D \proves \phi$, where $\Sigma_D$ is the set of elements from $\Sigma$ whose universal closures are the elements in $\Sigma'_D$.\footnote{Two elements in $\Sigma$ may have the same universal closure, so in constructing $\Sigma_D$ we make an arbitrary choice of a single element. Since $\Sigma'_D$ is finite, this does not require the Axiom of Choice. Alternatively, we may choose any enumeration (hence well-ordering) of $\Sigma$, which is possible since $\Sigma$ is countable, and pick the smallest relevant element.} Furthermore, $\Sigma_D \subseteq \Sigma$, so $\Sigma \proves \Sigma_D$. It follows that $\Sigma \proves \phi$ as claimed.
        
        Again the same is true for $\Sigma \limplies \phi$, namely that this implies that $\Sigma' \limplies \phi$. It suffices to show that $\Sigma' \limplies \Sigma$, and it further suffices to show that $\{ \sigma' \} \limplies \sigma$ for all $\sigma \in \Sigma$. But this is obvious.
    \end{enumerate}
    %
    That is, we have proved the following implications:
    %
    \begin{equation*}
        \Sigma \limplies \phi
        \quad \implies \quad
        \Sigma' \limplies \phi',
        \quad \text{and} \quad
        \Sigma' \proves \phi'
        \quad \implies \quad
        \Sigma \proves \phi.
    \end{equation*}
    %
    Hence for completeness it suffices to show that $\Sigma' \limplies \phi'$ implies $\Sigma' \proves \phi'$. We may make the following further simplification:
    %
    \begin{enumerate}[resume]
        \item It suffices to consider the case where $\phi$ is the sentence $\false$: For assume that $\Sigma \limplies \false$ implies $\Sigma \proves \false$, and that $\Sigma \limplies \phi$. Then $\Sigma \union (\neg \phi) \limplies \false$, implying that $\Sigma \union (\neg \phi) \proves \false$ by the assumption. This in turn implies that $\Sigma \proves \phi$ by \exref{2.7.4}.
    \end{enumerate}
    %
    We prove the contrapositive: If $\Sigma$ is consistent, then there is a model of $\Sigma$.

    \item[Extending $\calL$ and $\Sigma$ recursively]
    The model of $\Sigma$ we will construct will have a universe containing (equivalence classes of) variable-free terms, so we must ensure that $\calL$ has at least some constants. Furthermore, if $c$ is a constant and $P$ a unary predicate, then the set $\{\exists x P(x), \neg P(c)\}$ is consistent, but we must ensure the existence of a constant $c'$ such that $P(c')$ is true for this set to have a model. Hence we also add the axiom $\exists x P(x) \lcond P(c')$.
    
    We extend $\calL$ and $\Sigma$ by using the following constructions:
    %
    \begin{enumerate}
        \item We first \emph{extend $\calL$ by constants}: Let $c_n$ be a constant not in $\calL$ for all $n \in \posints$, and let $\tilde\calL = \calL \union \set{c_n}{n \in \posints}$. The constants $c_n$ are called \emph{Henkin constants}. Notice that since $\calL$ is countable, so is $\tilde\calL$. Furthermore, Lemma~3.2.3 shows that if $\Sigma$ is a consistent set of $\calL$-sentences, then it is also a consistent set of $\tilde\calL$-sentences.
        
        \item Since $\calL$ is countable, we may enumerate all sentences in $\calL$ on the form $(\exists x)(\theta)$. Notice that since these are sentences, the only free variable (if any) in $\theta$ is $x$. Denote these by $(\exists x)(\theta_n)$ for $n \in \posints$ and define the collection
        %
        \begin{equation*}
            \tilde{H}
                = \set{(\exists x)(\theta_n) \lcond \theta_n(c_n)}{\text{$(\exists x)(\theta_n)$ is an $\calL$-sentence}}
        \end{equation*}
        %
        of \emph{Henkin axioms}, where $\theta_n(c_n)$ is shorthand for $(\theta_n)^x_{c_n}$.

        \item Finally we define the set $\tilde\Sigma = \Sigma \union \tilde{H}$ of $\tilde\calL$-sentences. Lemma~3.2.4 shows that if $\Sigma$ is consistent, then $\tilde\Sigma$ is also consistent.
    \end{enumerate}
    %
    Notice that we must add a Henkin constant for each existential sentence: Otherwise if $P$ is a unary predicate and $c$ a Henkin constant, then it might happen that $\exists x P(x) \lcond P(c)$ and $\exists x \neg P(x) \lcond \neg P(c)$ are Henkin axioms. The set $\{\exists x P(x), \exists x \neg P(x)\}$ is consistent, but adding these axioms makes it inconsistent.

    Furthermore, it is not enough to perform this procedure once: We have only added a Henkin axiom for each existential $\calL$-sentence, but in extending $\calL$ to $\tilde\calL$ we might have added more existential sentences. Hence we apply the constructions above recursively as follows: Let $\calL_0 = \calL$ and $\Sigma_0 = \Sigma$. For $n \in \naturals$ we do the following:
    %
    \begin{enumerate}[label={(\alph*')}]
        \item Given a (countable) language $\calL_n$, extend it by constants to obtain $\calL_{n+1}$. Then $\Sigma_n$ is a consistent set of $\calL_{n+1}$-sentences.
        \item Construct the set $H_{n+1}$ of Henkin axioms in the language $\calL_{n+1}$.
        \item Define $\Sigma_{n+1} = \Sigma_n \union H_{n+1}$. Then $\Sigma_{n+1}$ is a consistent set of $\calL_{n+1}$-sentences.
    \end{enumerate}
    %
    Finally let $\calL' = \bigunion_{n\in\naturals} \calL_n$ and $\hat\Sigma = \bigunion_{n\in\naturals} \Sigma_n$. We claim that $\Sigma_n$ as well as $\hat\Sigma$ are consistent sets of $\calL'$-sentences: For $\Sigma_n$, notice that $\calL'$ can be obtained from $\calL_n$ by extending by constants, so Lemma~3.2.3 implies that $\Sigma_n$ is consistent. For $\hat\Sigma$, this is the content of \exref{3.2.2}

    \item[Maximal extension of $\hat\Sigma$]
    Since $\calL'$ is countable, there exists an enumeration $\{\sigma_k\}_{k \in \posints}$ of all $\calL'$-sentences. Let $\Sigma^0 = \hat\Sigma$ and let
    %
    \begin{equation*}
        \Sigma^{k+1} =
        \begin{cases}
            \Sigma^k \union \{ \sigma_{k+1} \},
                & \text{if $\Sigma^k \union \{ \sigma_{k+1} \}$ is consistent}, \\
                \Sigma^k \union \{ \neg\sigma_{k+1} \},
                & \text{otherwise}.
        \end{cases}
    \end{equation*}
    %
    Let $\Sigma' = \bigunion_{k\in\naturals} \Sigma^k$. Then each $\Sigma^k$ is consistent by \exref{3.2.3}, and $\Sigma'$ is consistent by \exref{3.2.2}. Furthermore, $\Sigma'$ is the maximal consistent extension of $\hat\Sigma$ since it contains all $\calL'$-sentences possible for consistency, and this is sufficient by Lemma~2.7.3. This also has the property that if $\sigma$ is a sentence, then $\sigma \in \Sigma'$ if and only if $\Sigma' \proves \sigma$ by \exref{3.2.5}.

    \item[Model of $\Sigma'$]
    First, let $T$ be the set of variable-free terms of $\calL'$, and let $t_1 \sim t_2$ if $(t_1 = t_2) \in \Sigma'$. \exref{3.2.7} shows that this is an equivalence relation. We construct the model $\frakA$ as follows:
    %
    \begin{enumerate}
        \item \emph{Universe}: The universe $A$ is the quotient $T/{\sim}$.

        \item \emph{Constants}: For each constant $c \in \calL'$ (including Henkin constants), we simply let $c^\frakA = [c]$, i.e. the $\sim$-equivalence class of $c$.

        \item \emph{Functions}: If $f$ is an $n$-ary function symbol, then we let
        %
        \begin{equation*}
            f^\frakA \bigl( [t_1], \ldots, [t_n] \bigr)
                = [f t_1 \cdots t_n].
        \end{equation*}
        %
        This is shown to be well-defined by an argument similar to that of \exref{3.2.7}, showing that $\proves (t_1 = t_2 \lcond f(t_1) = f(t_2))$.

        \item \emph{Relations}: Given an $n$-ary relation symbol $R$, we say that $R^\frakA([t_1], \ldots, [t_n])$ is true if $R t_1 \cdots t_n \in \Sigma'$. We show in \exref{3.2.8} that this is well-defined.
    \end{enumerate}
    %
    Proposition~3.2.6 now shows that $\frakA \models \Sigma'$ by showing that $\sigma \in \Sigma'$ if and only if $\frakA \models \sigma$ for all sentences $\sigma$. This is done as follows:
    %
    \begin{enumerate}
        \item If $\sigma$ is atomic, then this follows by definition of $\frakA$.
        
        \item If $\sigma$ is on the form $\neg\alpha$ or $\alpha \lor \beta$, then this easily follows by induction.
        
        \item If $(\forall x)\phi(x) \in \Sigma'$, then we must show that $\frakA \sats{s} \phi(t)$ for all $s$ and $t$, i.e. that $\frakA \models \phi(t)$ since $\phi(t)$ is a sentence. Since $(\forall x)\phi(x) \lcond \phi(t)$ is an axiom and $\Sigma' \proves (\forall x)\phi(x)$, then $\Sigma' \proves \phi(t)$. By induction, $\frakA \models \phi(t)$.

        Conversely, if $(\forall x)\phi(x) \not\in \Sigma'$ then $\neg(\forall x)\phi(x) \in \Sigma'$, and so $(\exists x)\neg\phi(x) \in \Sigma'$. There is a Henkin constant $c$ such that $[(\exists x)\neg\phi(x) \lcond \neg\phi(c)] \in \Sigma'$, so $\neg\phi(c) \in \Sigma'$. By induction, $\frakA \models \neg\phi(c)$, i.e. $\frakA \not\models \phi(c)$, which implies that $\frakA \not\models (\forall x)\phi(x)$.
    \end{enumerate}
    %
    In particular $\frakA \models \Sigma$.

    \item[Restricting $\frakA$ to $\calL$]
    Next define the restriction $\frakA|_\calL$ of $\frakA$ to $\calL$ in the obvious way. Then Lemma~3.2.7 shows that if $\sigma$ is an $\calL$-sentence, then $\frakA|_\calL \models \sigma$ if and only if $\frakA \models \sigma$. We prove this by showing that $\frakA|_\calL \models \sigma$ if and only if $\sigma \in \Sigma'$ as in the proof of Proposition~3.2.6. Thus we have $\frakA|_\calL \models \Sigma$ as desired.
\end{notelist}


\begin{remarkbreak}[$\overline{s}(t) = {[t]}$]
    \label{rem:assignment-function-variable-free}
    Let $t$ be a variable-free $\calL'$-term, and let $s$ be any assignment function into $\frakA$. Then we claim that $\overline{s}(t) = [t]$. (Of course, by Lemma~1.7.6 the value of $\overline{s}(t)$ should not depend on $s$, since $t$ contains no variables.) We show this by induction.

    If $c$ is a constant, then by definition $\overline{s}(c) = [c]$. If $t \colonequiv ft_1 \cdots t_n$, then by induction we have
    %
    \begin{equation*}
        \overline{s}(ft_1 \cdots t_n)
            = f^\frakA(\overline{s}(t_1), \ldots \overline{s}(t_n))
            = f^\frakA \bigl( [t_1], \ldots, [t_n] \bigr)
            = [ft_1 \cdots t_n].
    \end{equation*}
    %
    Notice that we here use the definition of $f^\frakA$: It is not immediately obvious where in the proof of Proposition~3.2.6 this is used, but this definition ensures that $R^\frakA$ is well-defined (see \exref{3.2.8}).
\end{remarkbreak}


\begin{exerciseframed}[3.2.2]
    Assume that $\Sigma_0 \subseteq \Sigma_1 \subseteq \Sigma_2 \subseteq \cdots$ are such that each $\Sigma_n$ is a consistent set of sentences in a language $\calL$. Show $\hat\Sigma = \bigunion_{n\in\naturals} \Sigma_n$ is consistent.
\end{exerciseframed}

\begin{solution}
    We prove that if $\hat\Sigma$ is inconsistent, then at least one $\Sigma_n$ is inconsistent, so let $D$ be a derivation of $\false$ from $\hat\Sigma$. Since $D$ is finite, it contains finitely many formulas from $\hat\Sigma$, say $\phi_1, \ldots, \phi_k$. Each $\phi_i$ then lies in some $\Sigma_i$, so let $n$ be the largest of these $i$. Then all $\phi_i$ lie in $\Sigma_n$, so $D$ is also a derivation of $\false$ from $\Sigma_n$, and hence $\Sigma_n$ is inconsistent.
\end{solution}


\begin{exerciseframed}[3.2.3]
    Show that if $\Pi$ is any consistent set of sentences and $\sigma$ is a sentence such that $\Pi \union \{\sigma\}$ is inconsistent, then $\Pi \union \{\neg\sigma\}$ is consistent.
\end{exerciseframed}

\begin{solution}
    We show that if $\Pi \union \{\neg\sigma\}$ is inconsistent, then so is $\Pi$. The former means that $\Pi \union \{\neg\sigma\} \proves \false$, which by \exref{2.7.4} implies that $\Pi \proves \sigma$. But since $\Pi \union \{\sigma\} \proves \false$ the same exercise implies that $\Pi \proves (\neg\sigma)$.\footnote{Here we use that we can derive $\sigma$ from $\neg\neg\sigma$, which is possible since the latter is a propositional consequence of the former.} Hence $\Pi \proves \{\sigma, (\neg\sigma)\}$, so $\Pi \proves \false$ by the same argument as in \exref{2.7.4}.
\end{solution}


\begin{exerciseframed}[3.2.5]
    Prove Lemma~3.2.5: If $\sigma$ is a sentence, then $\sigma \in \Sigma'$ if and only if $\Sigma' \proves \sigma$.
\end{exerciseframed}

\begin{solution}
    The \enquote{only if} part is obvious. The \enquote{if} part follows since if $\Sigma' \proves \sigma$ then $\Sigma' \union \{\sigma\}$ is consistent, and hence $\sigma \in \Sigma'$ by maximality.
\end{solution}


\begin{exerciseframed}[3.2.7]
    Complete the proof of the claim on page 80 that the relation $\sim$ is an equivalence relation.
\end{exerciseframed}

\begin{solution}
    The authors sketch a proof that $\sim$ is symmetric. We give a slightly different proof below. Notice that Theorem~2.7.1 shows that equality of \emph{variables} is an equivalence relation. We first show that equality of \emph{variable-free terms} is also an equivalence relation. % TODO: Only variable-free terms?
    
    Let $\phi(x,y,z)$ be one of the formulas in Theorem~2.7.1, so that $\proves \phi(x,y,z)$, and denote by $\phi(t_1,t_2,t_3)$ the formula obtained by replacing $x$ with the variable-free term $t_1$, $y$ with $t_2$, and $z$ with $t_3$ (notice that $t_1$ is substitutable for $x$, etc.). Then Lemma~2.7.2 shows that also $\proves (\forall x) (\forall y) (\forall z) \phi(x,y,z)$. The axiom (Q1) then has the instances
    %
    \begin{align*}
        (\forall x) (\forall y) (\forall z) \phi(x,y,z)
            &\lcond (\forall y) (\forall z) \phi(t_1,y,z), \\
        (\forall y) (\forall z) \phi(t_1,y,z)
            &\lcond (\forall z) \phi(t_1,t_2,z), \\
        (\forall z) \phi(t_1,t_2,z)
            &\lcond \phi(t_1,t_2,t_3),
    \end{align*}
    %
    from which it is easy to derive that $\proves \phi(t_1,t_2,t_3)$. Hence equality of terms is an equivalence relation.

    Next we prove that $\sim$ is transitive, since reflexivity and symmetry are easier, so assume that $t_1 \sim t_2$ and $t_2 \sim t_3$. By Lemma~3.2.5 (i.e. \exref{3.2.5}), this is the same as $\Sigma' \proves (t_1 = t_2)$ and $\Sigma' \proves (t_2 = t_3)$. Then it is clear that also $\Sigma' \proves [(t_1 = t_2) \land (t_2 = t_3)]$, and by the above this implies that $\Sigma' \proves (t_1 = t_3)$, i.e. that $t_1 \sim t_3$.
\end{solution}


\begin{exerciseframed}[3.2.8]
    Show that the relation $R^\frakA$ of the structure $\frakA$ is well-defined.
\end{exerciseframed}

\begin{solution}
    By Definition~1.7.4 and Definition~1.7.9, we say that $\frakA \models Rt_1 \cdots t_n$ if $(\overline{s}(t_1), \ldots, \overline{s}(t_n)) \in R^\frakA$ for all assignment functions $s$ into $\frakA$. By \cref{rem:assignment-function-variable-free} this means that $([t_1], \ldots, [t_n]) \in R^\frakA$, so we in other words define $R^\frakA$ by
    %
    \begin{equation*}
        R^\frakA
            = \set[\big]{ \bigl( [t_1], \ldots, [t_n] \bigr) \in A^n }{ Rt_1 \ldots t_n \in \Sigma' },
    \end{equation*}
    %
    and we must show that this is well-defined. An argument similar to that of \exref{3.2.7} shows that $\proves [t_1 = t_2 \lcond (R(t_1) \lcond R(t_2))]$, which implies well-definition.
\end{solution}


\end{document}